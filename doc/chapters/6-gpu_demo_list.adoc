////
  Copyright NXP 2019
  Author: Marco Franchi <marco.franchi@nxp.com>
////

[[gpu_demo_list]]
=== GPU

==== OpenVG 2D

===== Tiger G2D

Description of Vivante Tiger G2D

===== GPU Unit Test

Description of GPU Unit Test

==== GLES2

===== Bloom

image::bloom.jpg[pdfwidth=40%]

An example of how to create a bloom effect. The idea is not to create the most accurate bloom, but something that is fairly fast to render. Instead of increasing the kernal size to get a good blur we do a fairly fast approximation by downscaling the original image to multiple smaller render-targets and then blurring these using a relative small kernel and then finally rescaling the result to the original size.

Source code: {BLOOM}

===== Blur

image::blur.jpg[pdfwidth=40%]

Uses the two pass linear technique and further reduces the bandwidth requirement by downscaling the 'source image' to 1/4 its size (1/2w x 1/2h) before applying the blur and and then upscaling the blurred image to provide the final image. This works well for large kernel sizes and relatively high sigma's but the downscaling produces visible artifacts with low sigma's.

Source code: {BLUR}

===== DFGraphicsBasic2D

image::dfgraphicsbasic2d.jpg[pdfwidth=40%]

Shows how to use the Demo Frameworks 'basic' 2d rendering capabilities that work across all backends. The basic2D nterface allows you to render ASCII strings using a system provided font and draw colored points in batches. The functionality in Basic2D is used internally in the framework to render the profiling overlays like the frame rate counter and graphs.

Source code: {DFGRAPHICSBASIC2D}

===== DFSimpleUI100

image::dfsimpleui100.jpg[pdfwidth=40%]

A very basic example of how to utilize the DemoFramework's UI library. The sample displays four buttons and reacts to clicks. The UI framework that makes it easy to get a basic UI up and running. The main UI code is API independent. It is not a show case of how to render a UI fast but only intended to allow you to quickly get a UI ready that is good enough for a demo.

Source code: {DFSIMPLEUI100}

===== EightLayerBlend

image::eightlayerblend.jpg[pdfwidth=40%]

Creates a simple parallax scrolling effect by blending eight 32 bit per pixel 1080p layers on top of each other. This is not the most optimal way to do it as it uses eight passes. But it does provide a good example of the worst case bandwidth use for the operation. The demo was created to compare GLES to the G2D eight blend blit functionality.

Source code: {EIGHTLAYERBLEND}

===== FractalShader

image::fractalshader.jpg[pdfwidth=40%]

Can render both the julia and mandelbrot set using a fragment shader. This demo was used to demonstrates GPU shader performance by using up roughly 515 instructions to render each fragment while generating the julia set. It uses no textures, has no overdraw and has a minimal bandwidth requirement.

Source code: {FRACTALSHADER}

===== LineBuilder101

image::linebuilder101.jpg[pdfwidth=40%]

A simple example of dynamic line rendering using the LineBuilder helper class. The line builder has 'Add' methods for most FslBase.Math classes like BoundingBox, BoundingSphere, BoundingFrustrum, Ray, etc.

Source code: {LINEBUILDER101}

===== ModelLoaderBasics

image::modelloaderbasics.jpg[pdfwidth=40%]

Demonstrates how to use the FslSceneImporter and Assimp to load a scene and render it using OpenGLES2. The model is rendered using a simple per pixel directional light shader.

Source code: {MODELLOADERBASICS}

===== S03_Transform

image::s03_transform.jpg[pdfwidth=40%]

Renders a animated vertex colored triangle. This shows how to modify the model matrix to rotate a triangle and how to utilize demoTime.DeltaTime to do frame rate independent animation.

Source code: {S03_TRANSFORM}

===== S04_Projection

image::s04_projection.jpg[pdfwidth=40%]

This example shows how to: - Build a perspective projection matrix - Render two simple 3d models using frame rate independent animation.

Source code: {S04_PROJECTION}

===== S06_Texturing

image::s06_texturing.jpg[pdfwidth=40%]

This example shows how to use the Texture class to use a texture in a cube. It also shows you how to use the ContentManager service to load a 'png' file from the Content directory into a bitmap utility class which is then used to used to create a OpenGL ES texture.

Source code: {S06_TEXTURING}

===== S07_EnvironmentMapping

image::s07_environmentmapping.jpg[pdfwidth=40%]

This sample shows how to use a cubemap texture to simulate a reflective material. It also shows you how to use the ContentManager service to load a 'dds' file from the Content directory into a Texture utility class which is then used to used to create a OpenGL ES cubemap texture.

Source code: {S07_ENVIRONMENTMAPPING}

===== S08_EnvironmentMappingRefraction

image::s08_environmentmappingrefraction.jpg[pdfwidth=40%]

This sample is a variation from the previous sample, again, a cubemap texture is used, but this time instead of simulating a reflective material a refractive material is simulated. It also shows you how to use the ContentManager service to load a 'dds' file from the Content directory into a Texture utility class which is then used to used to create a OpenGL ES cubemap texture.

Source code: {S08_ENVIRONMENTMAPPINGREFRACTION}

<<<